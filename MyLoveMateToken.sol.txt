// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract MyLoveMateToken is ERC20, Ownable {
    uint256 private constant INITIAL_SUPPLY = 21_000_000 * 10**18;
    uint16 public burnPercent = 200; // 2% burn
    uint16 public constant BPS_DENOM = 10000;

    mapping(address => bool) private _isExcludedFromFee;

    event ExcludeFromFee(address indexed account, bool isExcluded);
    event BurnPercentUpdated(uint16 oldPercent, uint16 newPercent);

    constructor(
        address ownerAddress,
        address distributionWallet,
        address stakingWallet,
        address teamWallet,
        address liquidityWallet,
        address testWallet
    ) ERC20("MyLoveMate Token", "MLM") Ownable(ownerAddress) {
        require(distributionWallet != address(0));
        require(stakingWallet != address(0));
        require(teamWallet != address(0));
        require(liquidityWallet != address(0));
        require(testWallet != address(0));

        // Mint allocations
        _mint(distributionWallet, 15_000_000 * 10**18);
        _mint(stakingWallet, 3_000_000 * 10**18);
        _mint(teamWallet, 2_000_000 * 10**18);
        _mint(liquidityWallet, 1_000_000 * 10**18);

        // Exclude wallets from fee
        _isExcludedFromFee[ownerAddress] = true;
        _isExcludedFromFee[distributionWallet] = true;
        _isExcludedFromFee[stakingWallet] = true;
        _isExcludedFromFee[teamWallet] = true;
        _isExcludedFromFee[liquidityWallet] = true;
        _isExcludedFromFee[testWallet] = true;
    }

    // Check if account is excluded
    function isExcludedFromFee(address account) external view returns (bool) {
        return _isExcludedFromFee[account];
    }

    // Set exclusion
    function setExcludedFromFee(address account, bool excluded) external onlyOwner {
        _isExcludedFromFee[account] = excluded;
        emit ExcludeFromFee(account, excluded);
    }

    // Update burn percentage
    function setBurnPercent(uint16 newBps) external onlyOwner {
        require(newBps <= 1000, "Max 10%");
        uint16 old = burnPercent;
        burnPercent = newBps;
        emit BurnPercentUpdated(old, newBps);
    }

    // Custom transfer with burn
    function transferWithBurn(address to, uint256 amount) external returns (bool) {
        require(balanceOf(msg.sender) >= amount, "Insufficient balance");

        uint256 burnAmount = (_isExcludedFromFee[msg.sender] || _isExcludedFromFee[to]) ? 0 : (amount * burnPercent) / BPS_DENOM;
        uint256 sendAmount = amount - burnAmount;

        if (burnAmount > 0) {
            _burn(msg.sender, burnAmount);
        }

        _transfer(msg.sender, to, sendAmount);
        return true;
    }

    // Rescue ERC20 accidentally sent
    function rescueERC20(address tokenAddress, address to) external onlyOwner {
        require(to != address(0));
        IERC20 token = IERC20(tokenAddress);
        uint256 bal = token.balanceOf(address(this));
        require(bal > 0);
        token.transfer(to, bal);
    }
}
